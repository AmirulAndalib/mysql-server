# Recovery donor connection options test
# This test checks the user options used for donor connection during recovery.
#
# In this test the following points are checked:
#   1) The user/password fields cannot accept improper values.
#   2) The user used for the donor connection should be settable/readable.
#   3) The password can be set but when the user tries to read it, it should
#      be blank.
#   4) When given, correct fields should allow for a correct recovery
#   5) The retry count should be settable/readable.
#   6) When given, incorrect fields should cause recovery to fail, causing the
#      member to leave.

--source include/have_debug.inc
--source include/have_group_replication_plugin.inc

--let $group_replication_group_name= b5eb4110-a3a2-11e3-a5e2-0800200c9a66
--let $rpl_skip_group_replication_start= 1
--let $rpl_server_count= 3
--source include/master-slave.inc

--let $recovery_invalid_user= "thisusernamehasmorethan48characterssoitisinvalid."
--let $recovery_invalid_password= "thispasswordhasmorethan32chara..."

--let $debug_save_count= `SELECT @@GLOBAL.group_replication_recovery_retry_count`
--let $debug_save_user= `SELECT @@GLOBAL.group_replication_recovery_user`

--let $recovery_user= recovery_user
--let $recovery_password= recovery_password
--let $recovery_bad_password= recovery_bad_password

--echo #
--echo # Start the donor member
--echo #

--connection server1
--source include/start_group_replication.inc

--let $group_replication_number_of_members= 1
--source ../inc/group_replication_wait_for_number_of_members.inc

#insert some data
CREATE TABLE t1 (c1 INT NOT NULL PRIMARY KEY) ENGINE=InnoDB;
INSERT INTO t1 VALUES (1);

--echo #
--echo # Install a rpl user for the donor connection
--echo #

--eval CREATE USER "$recovery_user" IDENTIFIED BY "$recovery_password"
--eval GRANT REPLICATION SLAVE ON *.* TO "$recovery_user"
FLUSH PRIVILEGES;

--echo #
--echo # Install the joiner member and try to set invalid values
--echo #

--connection server2

set session sql_log_bin=0;
call mtr.add_suppression("The given user name for recovery*");
call mtr.add_suppression("The given password for recovery*");
set session sql_log_bin=1;

--error ER_WRONG_VALUE_FOR_VAR
--eval SET GLOBAL group_replication_recovery_user= $recovery_invalid_user
--error ER_WRONG_VALUE_FOR_VAR
--eval SET GLOBAL group_replication_recovery_password= $recovery_invalid_password

--echo #
--echo # Set and check valid options
--echo #

--eval SET GLOBAL group_replication_recovery_user= $recovery_user
--eval SET GLOBAL group_replication_recovery_password= $recovery_password

--let $assert_text= The value of the recovery user name should be $recovery_user
--let $assert_cond= "[SELECT @@group_replication_recovery_user]" = "$recovery_user"
--source include/assert.inc

--let $assert_text= The value of the recovery password should be empty
--let $assert_cond= "[SELECT @@group_replication_recovery_password]" = ""
--source include/assert.inc

--echo #
--echo # Start the joiner member with the given credentials and check if it is OK
--echo #

--source include/start_group_replication.inc

let $assert_text= On the recovered member, the table should contain 1 elements;
let $assert_cond= [select count(*) from t1] = 1;
source include/assert.inc;

--echo #
--echo # Create a new member and give it a bad password, watching it fail
--echo #

SET @debug_save= @@GLOBAL.DEBUG;

--connection server3
set session sql_log_bin=0;
call mtr.add_suppression("There was an error when connecting to the donor*");
call mtr.add_suppression("Maximum number of retries when*");
call mtr.add_suppression("Fatal error during the Recovery process of Group Replication. The server will leave the group.");
set session sql_log_bin=1;

--eval SET GLOBAL group_replication_recovery_user= $recovery_user
--eval SET GLOBAL group_replication_recovery_password= $recovery_bad_password

--echo # Set the retry count to try only twice. One time for each member.
--eval SET GLOBAL group_replication_recovery_retry_count= 2;

--let $assert_text= The value of the recovery retry count should be equal to 2
--let $assert_cond= "[SELECT @@group_replication_recovery_retry_count]" = "2"
--source include/assert.inc

--echo # Start recovery and wait to verify the member is in recovery

SET @@GLOBAL.DEBUG='d,recovery_thread_wait';
SET GLOBAL group_replication_group_name= "b5eb4110-a3a2-11e3-a5e2-0800200c9a66";
START GROUP_REPLICATION;

--let $group_replication_member_state= RECOVERING
--source ../inc/group_replication_wait_for_member_state.inc

--echo # Wake up recovery

SET @@GLOBAL.DEBUG= @debug_save;
SET DEBUG_SYNC= "now SIGNAL signal.recovery_continue";

--echo # The member should become offline as it can't connect

--let $group_replication_member_state= OFFLINE
--source ../inc/group_replication_wait_for_member_state.inc

# Remove the plugin on the failed member

--connection server2
--let $group_replication_number_of_members= 2
--source ../inc/group_replication_wait_for_number_of_members.inc

--echo #
--echo # Clean up
--echo #

--eval DROP USER "$recovery_user"
--connection server3
--eval SET GLOBAL group_replication_recovery_user= $debug_save_user
--eval SET GLOBAL group_replication_recovery_retry_count= $debug_save_count

--connection server2
--eval SET GLOBAL group_replication_recovery_user= $debug_save_user
DROP TABLE t1;

--source include/rpl_end.inc
