# Test to check the query size limitation of the GCS binding in use.
# Currently we are using Corosync 1.4.6 for the test. For version below 1.4.6
# the test will fail due to different size of the maximum sized packet that is
# sent.
#
# The limits specified in the test can be changed to tune the test for
# diferent versions/bidings.

--source include/have_group_replication_plugin.inc
--source include/master-slave.inc

#    The test is implemented as follows:
#
#    On Node 1 :
#      create tables on the node.
#      create a procedure to insert some numbers of rows in different conditions.
#
#    On Node 2 :
#      check that the data is replicated correctly and no failure happened
#      during the GCS message broadcast.


#Known current biding size limitations
--let $max_single_insert_size = 499
--let $max_number_1kb_inserts_1_table = 459
--let $max_number_1kb_inserts_N_tables = 457

--connection server1
--let $file= $MYSQLTEST_VARDIR/tmp/temp_file.data

# CASE I - 1 insert of size almost 499 kb.

--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
--eval SELECT repeat('x',1024*($max_single_insert_size)) INTO OUTFILE '$file'

CREATE TABLE t1 (a INT, t LONGTEXT, PRIMARY KEY(a));
DELIMITER |;
CREATE PROCEDURE p(file varchar(1200))
  BEGIN
    INSERT INTO t1 VALUES (1, LOAD_FILE(file));
  END|
DELIMITER ;|

--connection server1
--replace_result $file FILE
--eval CALL p('$file')

--remove_file $file

--connection server1
--source include/rpl_sync.inc

--let $diff_tables= server1:t1, server2:t1
--source include/diff_tables.inc

# Case II - N inserts of 1kB in one table

--connection server1

--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR

DELIMITER |;
CREATE PROCEDURE p1(lim int)
  BEGIN
        DECLARE stmt2 VARCHAR(10000);
        DECLARE v1 INT DEFAULT 2;
        WHILE v1 < lim DO
                INSERT INTO t1 VALUES (v1, REPEAT('X',1024));
                SET v1=v1+1;
        END WHILE;
  END|
DELIMITER ;|

--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
SET AUTOCOMMIT=0;
BEGIN;
--eval CALL p1($max_number_1kb_inserts_1_table)
COMMIT;

--connection server1
--source include/rpl_sync.inc

--let $diff_tables= server1:t1, server2:t1
--source include/diff_tables.inc

# Case III - 1 insert of 1kB to N tables

--connection server1

--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR

DROP TABLE IF EXISTS t1;

--let $count=1
while($count < $max_number_1kb_inserts_N_tables)
{
  --eval CREATE TABLE t$count (a INT, t LONGTEXT, PRIMARY KEY(a));
  --inc $count
}

--connection server1
--source include/rpl_sync.inc

--connection server1
DELIMITER |;
CREATE PROCEDURE p2(lim int)
   BEGIN
         DECLARE v1 INT DEFAULT 1;
         DECLARE x VARCHAR(10);
         DECLARE stmt2 VARCHAR(2000);
         WHILE v1 < lim DO
                 SET @x = v1;
                 SET @s2 = CONCAT("INSERT INTO t", @x, " VALUES (", @x, ", REPEAT('X', 1024))");
                 PREPARE stmt2 from @s2;
                 EXECUTE stmt2;
                 SET v1 = v1 + 1;
         END WHILE;
   END|
DELIMITER ;|

--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
BEGIN;
--eval CALL p2($max_number_1kb_inserts_N_tables)
COMMIT;

--connection server1
--source include/rpl_sync.inc

--let $i= 1
while ($i < $max_number_1kb_inserts_N_tables)
{
  --let $diff_tables= server1:t$i, server2:t$i
  --source include/diff_tables.inc
  --inc $i
}

# CLEAN UP
--connection server1
--let $i= 1
while ($i < $max_number_1kb_inserts_N_tables)
{
  --eval DROP TABLE t$i
  --inc $i
}
DROP PROCEDURE p;
DROP PROCEDURE p1;
DROP PROCEDURE p2;

--source include/rpl_end.inc
