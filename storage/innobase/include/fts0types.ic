/*****************************************************************************

Copyright (c) 2007, 2014, Oracle and/or its affiliates. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA

*****************************************************************************/

/******************************************************************//**
@file include/fts0types.ic
Full text search types.

Created 2007-03-27 Sunny Bains
*******************************************************/

#ifndef INNOBASE_FTS0TYPES_IC
#define INNOBASE_FTS0TYPES_IC

#include "rem0cmp.h"
#include "ha_prototypes.h"

/******************************************************************//**
Duplicate a string.
@return < 0 if n1 < n2, 0 if n1 == n2, > 0 if n1 > n2 */
UNIV_INLINE
void
fts_string_dup(
/*===========*/
	fts_string_t*		dst,		/*!< in: dup to here */
	const fts_string_t*	src,		/*!< in: src string */
	mem_heap_t*		heap)		/*!< in: heap to use */
{
	dst->f_str = (byte*)mem_heap_alloc(heap, src->f_len + 1);
	memcpy(dst->f_str, src->f_str, src->f_len);

	dst->f_len = src->f_len;
	dst->f_str[src->f_len] = 0;
	dst->f_n_char = src->f_n_char;
}

/******************************************************************//**
Compare two fts_trx_row_t doc_ids.
@return < 0 if n1 < n2, 0 if n1 == n2, > 0 if n1 > n2 */
UNIV_INLINE
int
fts_trx_row_doc_id_cmp(
/*===================*/
	const void*	p1,			/*!< in: id1 */
	const void*	p2)			/*!< in: id2 */
{
	const fts_trx_row_t*	tr1 = (const fts_trx_row_t*) p1;
	const fts_trx_row_t*	tr2 = (const fts_trx_row_t*) p2;

	return((int)(tr1->doc_id - tr2->doc_id));
}

/******************************************************************//**
Compare two fts_ranking_t doc_ids.
@return < 0 if n1 < n2, 0 if n1 == n2, > 0 if n1 > n2 */
UNIV_INLINE
int
fts_ranking_doc_id_cmp(
/*===================*/
	const void*	p1,			/*!< in: id1 */
	const void*	p2)			/*!< in: id2 */
{
	const fts_ranking_t*	rk1 = (const fts_ranking_t*) p1;
	const fts_ranking_t*	rk2 = (const fts_ranking_t*) p2;

	return((int)(rk1->doc_id - rk2->doc_id));
}

/******************************************************************//**
Compare two fts_update_t doc_ids.
@return < 0 if n1 < n2, 0 if n1 == n2, > 0 if n1 > n2 */
UNIV_INLINE
int
fts_update_doc_id_cmp(
/*==================*/
	const void*	p1,			/*!< in: id1 */
	const void*	p2)			/*!< in: id2 */
{
	const fts_update_t*	up1 = (const fts_update_t*) p1;
	const fts_update_t*	up2 = (const fts_update_t*) p2;

	return((int)(up1->doc_id - up2->doc_id));
}

/******************************************************************//**
Get the first character's code position for FTS index partition */
extern
ulint
innobase_strnxfrm(
/*==============*/
        const CHARSET_INFO*	cs,	/*!< in: Character set */
        const uchar*		p2,	/*!< in: string */
        const ulint		len2);	/*!< in: string length */

/******************************************************************//**
Select the FTS auxiliary index for the given character.
@return the index to use for the string */
UNIV_INLINE
ulint
fts_select_index(
/*=============*/
	const CHARSET_INFO*	cs,	/*!< in: Charset */
	const byte*		str,	/*!< in: string */
	ulint			len)	/*!< in: string length */
{
	ulint			selected = 0;
	ulint			value = innobase_strnxfrm(cs, str, len);

	while (fts_index_selector[selected].value != 0) {

		if (fts_index_selector[selected].value == value) {

			return(selected);

		} else if (fts_index_selector[selected].value > value) {

			return(selected > 0 ? selected - 1 : 0);
		}

		++selected;
	}

	ut_ad(selected > 1);

	return(selected - 1);
}

/******************************************************************//**
Select the next FTS auxiliary index for the given character.
@return the next index to use for character */
UNIV_INLINE
ulint
fts_select_next_index(
/*==================*/
	const CHARSET_INFO*	cs,	/*!< in: Charset */
	const byte*		str,	/*!< in: string */
	ulint			len)	/*!< in: string length */
{
	ulint		selected = 0;
	ulint		value = innobase_strnxfrm(cs, str, len);

	while (fts_index_selector[selected].value != 0) {

		if (fts_index_selector[selected].value == value) {

			return(selected + 1);

		} else if (fts_index_selector[selected].value > value) {

			return(selected);
		}

		++selected;
	}

	ut_ad(selected > 0);

	return((ulint) selected);
}

/******************************************************************//**
Return the selected FTS aux index suffix. */
UNIV_INLINE
const char*
fts_get_suffix(
/*===========*/
	ulint		selected)	/*!< in: selected index */
{
	return(fts_index_selector[selected].suffix);
}

/******************************************************************//**
Get the number of index selectors.
@return The number of selectors */
UNIV_INLINE
ulint
fts_get_n_selectors(void)
/*=====================*/
{
	ulint	i = 0;

	// FIXME: This is a hack
	while (fts_index_selector[i].value != 0) {
		++i;
	}

	return(i);
}

#endif /* INNOBASE_FTS0TYPES_IC */
