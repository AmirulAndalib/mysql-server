#
# Test case to verify that concurrent transactions with intersecting
# write set, the same primary key, do conflict.
#
# Scenario 8.2: WL#6834
#
# T1: WS={t1.a= 1}
#
# T2: WS={t1.a= 1}
#
# Outcome: T1 must abort, T2 must commit.
#
# Full details on WL#6834 QA notes.
#
#

--source include/have_debug_sync.inc
--source include/have_gcs_replication_plugin.inc
--source include/master-slave.inc

--echo
--echo ############################################################
--echo # 1. Create a table on server1.
--let $rpl_connection_name= server1
--source include/rpl_connection.inc
CREATE TABLE t1 (c1 INT PRIMARY KEY);
--source include/rpl_sync.inc

--echo
--echo ############################################################
--echo # 2. Set a debug sync before broadcast message to group on
--echo #    connection server_1.
--echo #    Commit a transaction that will be block before broadcast.
--let $rpl_connection_name= server_1
--source include/rpl_connection.inc
SET DEBUG_SYNC='gcs_before_message_broadcast WAIT_FOR waiting';
BEGIN;
INSERT INTO t1 VALUES (1);
--send COMMIT

--echo
--echo ############################################################
--echo # 3. Wait until server_1 connection reaches the
--echo # gcs_before_message_broadcast debug sync point.
--let $rpl_connection_name= server1
--source include/rpl_connection.inc
--let $wait_condition=SELECT COUNT(*)=1 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE State = 'debug sync point: gcs_before_message_broadcast'
--source include/wait_condition.inc

--echo
--echo ############################################################
--echo # 4. Execute a transaction on server2, that will reach first
--echo #    certification, since server_1 is blocked before broadcast.
--let $rpl_connection_name= server2
--source include/rpl_connection.inc
INSERT INTO t1 VALUES (1);
--let $sync_slave_connection= server1
--source include/sync_slave_sql_with_master.inc

--echo
--echo ############################################################
--echo # 5. Signal the waiting thread on server_1 to resume.
--let $rpl_connection_name= server1
--source include/rpl_connection.inc
SET DEBUG_SYNC='now SIGNAL waiting';

--echo
--echo ############################################################
--echo # 6. It will end up in an error stating that it was aborted,
--echo #    since transactions are conflicting and server2 was
--echo #    ordered first.
--let $rpl_connection_name= server_1
--source include/rpl_connection.inc
--error ER_ERROR_DURING_COMMIT,ER_ERROR_DURING_ROLLBACK
--reap

--echo
--echo ############################################################
--echo # 7. Assert that number of certified transactions are the
--echo #    expected ones.
--let $rpl_connection_name= server1
--source include/rpl_connection.inc

--let $certified_transactions= query_get_value(SELECT Certified_transactions from performance_schema.replication_node_status, Certified_transactions, 1)
--let $assert_text= The value of Certified_transactions should be 3 after starting gcs
--let $assert_cond= "$certified_transactions" = 3
--source include/assert.inc

--let $positively_certified= query_get_value(SELECT Positively_certified from performance_schema.replication_node_status, Positively_certified, 1)
--let $assert_text= The value of Positively_certified should be 2 after starting gcs
--let $assert_cond= "$positively_certified" = 2
--source include/assert.inc

--let $negatively_certified= query_get_value(SELECT Negatively_certified from performance_schema.replication_node_status, Negatively_certified, 1)
--let $assert_text= The value of Negatively_certified should be 1 after starting gcs
--let $assert_cond= "$negatively_certified" = 1
--source include/assert.inc

--echo
--echo ############################################################
--echo # Checking the positive case in which there is no conflict.
--echo ############################################################
--echo
--echo ############################################################
--echo # 1. Set a debug sync before broadcast message to group on
--echo #    connection server_1.
--echo #    Commit a transaction that will be block before broadcast.
--let $rpl_connection_name= server_1
--source include/rpl_connection.inc
SET DEBUG_SYNC='gcs_before_message_broadcast WAIT_FOR waiting';
BEGIN;
INSERT INTO t1 VALUES (2);
--send COMMIT

--echo
--echo ############################################################
--echo # 2. Wait until server_1 connection reaches the
--echo # gcs_before_message_broadcast debug sync point.
--let $rpl_connection_name= server1
--source include/rpl_connection.inc
--let $wait_condition=SELECT COUNT(*)=1 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE State = 'debug sync point: gcs_before_message_broadcast'
--source include/wait_condition.inc

--echo
--echo ############################################################
--echo # 3. Execute a transaction on server2, that will reach first
--echo #    certification, since server_1 is blocked before broadcast.
--let $rpl_connection_name= server2
--source include/rpl_connection.inc
INSERT INTO t1 VALUES (3);
--let $sync_slave_connection= server1
--source include/sync_slave_sql_with_master.inc

--echo
--echo ############################################################
--echo # 4. Signal the waiting thread on server_1 to resume.
--let $rpl_connection_name= server1
--source include/rpl_connection.inc
SET DEBUG_SYNC='now SIGNAL waiting';

--echo
--echo ########################################################################
--echo # 5. It will execute without error as the conflicting transactions have
--echo #    been removed.
--let $rpl_connection_name= server_1
--source include/rpl_connection.inc
--reap

--source include/rpl_sync.inc
--echo
--echo ############################################################
--echo # 6. Assert that number of certified transactions are the
--echo #    expected ones.
--let $rpl_connection_name= server1
--source include/rpl_connection.inc

--let $assert_text= Table t1 will contain row after the above execution
--let $assert_cond= "[SELECT COUNT(*) AS count FROM t1 WHERE t1.c1 = 1, count, 1]" = "1"
--source include/assert.inc

--let $assert_text= Table t1 will contain row after the above execution
--let $assert_cond= "[SELECT COUNT(*) AS count FROM t1 WHERE t1.c1 = 2, count, 1]" = "1"
--source include/assert.inc

--let $assert_text= Table t1 will contain row after the above execution
--let $assert_cond= "[SELECT COUNT(*) AS count FROM t1 WHERE t1.c1 = 3, count, 1]" = "1"
--source include/assert.inc

--let $assert_text= Table t1 will contain 3 rows after the above execution
--let $assert_cond= "[SELECT COUNT(*) FROM t1]" = "3"
--source include/assert.inc

--let $certified_transactions= query_get_value(SELECT Certified_transactions from performance_schema.replication_node_status, Certified_transactions, 1)
--let $assert_text= The value of Certified_transactions should be 5 after starting gcs
--let $assert_cond= "$certified_transactions" = 5
--source include/assert.inc

--let $positively_certified= query_get_value(SELECT Positively_certified from performance_schema.replication_node_status, Positively_certified, 1)
--let $assert_text= The value of Positively_certified should be 4 after starting gcs
--let $assert_cond= "$positively_certified" = 4
--source include/assert.inc

--let $negatively_certified= query_get_value(SELECT Negatively_certified from performance_schema.replication_node_status, Negatively_certified, 1)
--let $assert_text= The value of Negatively_certified should be 1 after starting gcs
--let $assert_cond= "$negatively_certified" = 1
--source include/assert.inc

--echo
--echo ############################################################
--echo # Clean up.
DROP TABLE t1;

--source include/rpl_end.inc
